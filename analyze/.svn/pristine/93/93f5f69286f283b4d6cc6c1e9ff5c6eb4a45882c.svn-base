function [specDat, data] = calcPowerSpec(Day, Rec, drive, specType, specParams, datParams, data)

%[specDat, data] = calcPowerSpec(Day, REc, drive, specType, specParams, datParams);
%
%wrapper function to load and pre-process time-series data and call tfspec to calculate power-spectra 
%loads time-series of data. Divides into arbitrary trials, identifies
%artifact trials, then computes spectra. Options available for how to
%compute spectra. 
%
%INPUTS: Day - string with recording day 'YYMMDD' format
%        Rec - recording number(s) to use. Format options:
%               numeric vector (e.g. [1 2 3])
%               string or cell of strings (e.g. '001' or {'001', '002'})
%               empty or 'all' to use all recordings from a day
%        drive - drives to load. Format options:
%                numeric vector reffering to drive index in exp defn file (e.g. [1 2 3])
%                string or cell of strings with drive names (as set in exp defn file (e.g. 'PMd', or {'PMd', 'M1'})
%        specType - type of spectral estimate to calculate (string). Options:
%                  'indChan_trAvg' - estimate each channel individually, average over trials (created
%                                    arbitrarily by dividing data into chunks) within each channel
%
%        specParams - structure with optional parameters for tfspec.
%           Fields:
%           -'tapers' - tapers to use in [K,TIME], [N,P,K] or [N,W] form.
%			   	        [N,W] Form:  N = duration of analysis window in s.
%                                    W = bandwidth of frequency smoothing in Hz. (default: [1 3 3])
%           -'dn'     - time overlap between neighboring windows
%           -'fk'     - cutoff frequency (Hz) (default: 500)
%           -'pad'    - flag to pad data or not (default: [])
%           -'pval'   - flag to calculate p-values on spectral estimates (default: [])
%        datParams   - structure with optional parameters for loading/pre-processing data        
%           -fileType - type of file to load (e.g. 'raw' , 'lfp', 'clfp'(default)  etc.).
%           -recLen   - length of time to load from each rec file in seconds (default: all)
%           -trLen    - length of 'trials' in seconds (default: 5)
%           -sigmaThreshold - number of SD from mean to use as indicator of an artifact (default: 5)
%       data - if data is already loaded, can provide as input to
%              skip re-loading. Expects data to be formatted as outlined in
%              readTSdat. trial-sorted data can be specified with '_tr' tag in the field. 
%OUTPUT:specDat - (#drives x 1) structure. Fields:
%                PS - power spectral data (size depends on specType)
%                freq - frequency values for spectral estimates
%                drive - name of drive
%       data - (# drives x 1) structure. Fields:
%               tsDat      - time series (#electrodes x time) data
%               recID      - index of recording file each time-sample belongs to (1 x time)
%               drive      - name of drive
%               Fs         - sampling rate
%               trDat      - time series (#electrodes x time x trials) of trial-sorted data
%               artTr      - flag identifiying artifacts (#electrodes x trials)
%               datType    - fileType of data loaded
%               datParams  - copy of data parameters
%
%A. Orsborn, 2015


if exist('specParams', 'var')
    fn = fieldnames(specParams);
else
    fn = {};
    specParams = struct([]);
end
parameters = {'tapers', 'dn', 'fk', 'pad', 'pval'}; %rec length in s
defaults   = {[1 3 3],  0.05,  500,  [],    []}; %#ok<NASGU>

for i=1:length(parameters)
    if ~ismember(parameters{i}, fn)
        eval(['specParams(1).', parameters{i}, '= defaults{i};'])
    end
end

if exist('datParams', 'var')
    fn = fieldnames(datParams);
else
    fn = {};
    datParams = struct([]);
end
parameters = {'fileType', 'trLen', 'sigmaThreshold', 'recLen'}; %rec length in s
defaults   = {'clfp',      5,        5,                inf}; %#ok<NASGU>

for i=1:length(parameters)
    if ~ismember(parameters{i}, fn)
        eval(['datParams(1).', parameters{i}, '= defaults{i};'])
    end
end


%load up data if not input
if ~exist('data', 'var')
    data = readTSdat(Day, Rec, drive, datParams.fileType, datParams.recLen);
end
nDrive = size(data,1);

specDat = struct('PS', [], 'freq', [], 'drive', [], 'datType', []);
for iD=1:nDrive
   
    Fs = data(iD).Fs;
    %eval(['dat = data(iD).', datParams.fileType, ';']);
    
    dat = data(iD).tsDat;
    fields = fieldnames(data(iD));
    if ~ismember([datParams.fileType, '_tr'], fields)
        %divide data into arbitrary trials
        trDat = createArbitraryTrials(dat, datParams.trLen, Fs);
        data(iD).trSortDat = trDat;
        %eval(['data(iD).', datParams.fileType, '_tr = trDat;'])
    else
        trDat = data(iD).trSortDat;
        %eval(['trDat = data(iD).', datParams.fileType, '_tr;'])
    end
    
    if ~ismember([datParams.fileType, '_artTr'], fields)
        %reject artifacts
        artTr = findArtifactTrials(trDat, datParams.sigmaThreshold);
        data(iD).artTr = artTr;
        %eval(['data(iD).', datParams.fileType, '_artTr = artTr;'])
    else
        artTr = data(iD).artTr;
        %eval(['artTr = data(iD).', datParams.fileType, '_artTr;'])
    end
    
    data(iD).datParams = datParams;
    switch specType
        
        %compute separately for each channel, averaged across trials (no mean subtraction)
        case {'indChan_trAvg'}
            
            for iC = 1:size(trDat,1)
                
                %tf spec wants tr/ch x time
                [s, freq] = tfspec(sq(trDat(iC,:,~artTr(iC,:)))', specParams.tapers, Fs, specParams.dn, ...
                    specParams.fk,specParams.pad, specParams.pval, 1);
                
                if iC==1
                    specDat(iD).PS = nan(size(trDat,1), size(s,1), size(s,2));
                    specDat(iD).PS(iC,:,:) = s;
                    specDat(iD).freq = freq;
                else
                    specDat(iD).PS(iC,:,:) = s;
                end
            end
            

    end
    
    specDat(iD).drive = data(iD).drive;
    specDat(iD).datType = datParams.fileType;
    
end
    
    
    
    
